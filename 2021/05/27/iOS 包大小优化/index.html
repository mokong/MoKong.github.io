<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>正经分析iOS包大小优化 | 今是昨非的博客</title><meta name="author" content="今是昨非"><meta name="copyright" content="今是昨非"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文发表在《搜狐技术产品》公众号正经分析iOS包大小优化 iOS 包大小分析优化背景包大小优化是项目开发中不可避免会遇到的，网上关于包大小优化的文章很多，每篇文章说的都不尽相同，笔者曾经根据网上的文章做过包大小优化，但效果不尽人意；因此笔者想根据已有的文章、知识结合自己的理解、实践，做一份总结梳理，整理自己的包大小优化逻辑，不光要知道怎么做可以让包大小变化，还要知道为什么这么做能产生效果，所以就有">
<meta property="og:type" content="article">
<meta property="og:title" content="正经分析iOS包大小优化">
<meta property="og:url" content="http://morganwang.cn/2021/05/27/iOS%20%E5%8C%85%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="今是昨非的博客">
<meta property="og:description" content="本文发表在《搜狐技术产品》公众号正经分析iOS包大小优化 iOS 包大小分析优化背景包大小优化是项目开发中不可避免会遇到的，网上关于包大小优化的文章很多，每篇文章说的都不尽相同，笔者曾经根据网上的文章做过包大小优化，但效果不尽人意；因此笔者想根据已有的文章、知识结合自己的理解、实践，做一份总结梳理，整理自己的包大小优化逻辑，不光要知道怎么做可以让包大小变化，还要知道为什么这么做能产生效果，所以就有">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://morganwang.cn/assets/img/avatar.jpeg">
<meta property="article:published_time" content="2021-05-27T05:43:00.000Z">
<meta property="article:modified_time" content="2024-01-22T11:04:42.000Z">
<meta property="article:author" content="今是昨非">
<meta property="article:tag" content="技术">
<meta property="article:tag" content="iOS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://morganwang.cn/assets/img/avatar.jpeg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "正经分析iOS包大小优化",
  "url": "http://morganwang.cn/2021/05/27/iOS%20%E5%8C%85%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96/",
  "image": "http://morganwang.cn/assets/img/avatar.jpeg",
  "datePublished": "2021-05-27T05:43:00.000Z",
  "dateModified": "2024-01-22T11:04:42.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "今是昨非",
      "url": "http://morganwang.cn"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://morganwang.cn/2021/05/27/iOS%20%E5%8C%85%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '正经分析iOS包大小优化',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/assets/img/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">188</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://images.unsplash.com/photo-1477346611705-65d1883cee1e);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">今是昨非的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">正经分析iOS包大小优化</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">正经分析iOS包大小优化</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-27T05:43:00.000Z" title="发表于 2021-05-27 13:43:00">2021-05-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-22T11:04:42.000Z" title="更新于 2024-01-22 19:04:42">2024-01-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p><strong>本文发表在《搜狐技术产品》公众号<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/_Mvl0FGriKsvAyRheU2Z7w">正经分析iOS包大小优化</a></strong></p>
<h1 id="iOS-包大小分析优化"><a href="#iOS-包大小分析优化" class="headerlink" title="iOS 包大小分析优化"></a>iOS 包大小分析优化</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>包大小优化是项目开发中不可避免会遇到的，网上关于包大小优化的文章很多，每篇文章说的都不尽相同，笔者曾经根据网上的文章做过包大小优化，但效果不尽人意；因此笔者想根据已有的文章、知识结合自己的理解、实践，做一份总结梳理，整理自己的包大小优化逻辑，不光要知道怎么做可以让包大小变化，还要知道为什么这么做能产生效果，所以就有了这篇文章。</p>
<span id="more"></span>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>想要优化安装包大小，首先需要弄清楚影响安装包大小的因素有哪些？之前笔者优化包大小直接闷着头就去瘦身，瘦来瘦去也没瘦出个名堂，而且还跟别人说不清楚自己做了什么，为什么这么做？</p>
<p>后来总结出来，做事之前要先思考、分析、最后再去做，要思考的是影响这件事的因素有哪些，一一列举出来，查漏补缺；然后针对这些因素进行分析，分析哪些因素是人为可控的，哪些因素是不能改变的，针对可控的部分要怎么优化，不可控的部分是否能避免，最好可以使用思维导图工具，一一记录；然后按照思维导图的整理出来的数据，按步骤去执行。</p>
<p>回过头来，针对安装包大小，首先分析影响安装包大小的因素，有：Xcode的设置、资源、代码三个方面。那针对这几个方面要怎么优化？以及如何查看每一步优化的结果？</p>
<p>首先是怎么优化的问题：</p>
<p>Xcode的编译设置优化，Xcode设置影响的是生成包的大小，通过Xcode编译选项优化的设置，让生成的ipa包变小，比如不含断点调试、去掉异常支持等等。</p>
<p>资源文件的优化，资源不光有图片资源，也包含代码资源和其它导入的资源，可以通过分析安装包构成，看里面哪些部分比较大、不合理，从而进行优化。</p>
<p>代码的优化，通过Link Map生成Link Map File，分析Link Map File各文件占用，结合Mach-O文件进行分析优化。</p>
<p>然后是怎么查看每一步优化的结果的问题：</p>
<p>查看每一步的优化结果，可以通过分析打包出来的ipa的大小，以及ipa的组成，与初始的ipa包大小比较，即可直观得到优化的结果。但可以更进一步，分析ipa的构成，对比优化后的构成，看每一步的操作具体影响的是包的哪一块儿，从而导致包的大小发生了变化。所以先来看一下一个ipa的包包含哪些内容，然后每一步优化之后，对应ipa的哪一部分发生了变化？</p>
<h3 id="安装包的构成"><a href="#安装包的构成" class="headerlink" title="安装包的构成"></a>安装包的构成</h3><p>iOS打包出来的ipa，本质上是一个压缩包，所以可以将.ipa的后缀改为.zip，然后进行解压缩，之后会得到一个Payload文件夹，里面又一个xxx.app的文件，这个xxx.app就是包含所有文件的包了，选中xxx.app，右键显示包内容，即可看到里面具体包含的东西了，大致如下：</p>
<p>安装包：</p>
<ul>
<li>_CodeSignature：  ipa包签名文件</li>
<li>.lproj：      语言文件</li>
<li>Frameworks：      第三库、SwiftSupport库</li>
<li>Plugins：         App创建的扩展，比如：Widget、Push、分享</li>
<li>Assets.car：      由Assets.xcassets生成的资源文件，里面包含各种分辨率的图片</li>
<li>embedded.mobileprovision：证书配置文件</li>
<li>Info.plist：      项目配置</li>
<li>exec格式的xxx：    可执行包</li>
<li>其它资源文件<ul>
<li>.mp3格式的文件</li>
<li>.html的文件</li>
<li>.json的文件</li>
<li>.png或者.jpg的文件</li>
</ul>
</li>
</ul>
<p>示例如下，Ps：不得不说，笔者这个ipa包含的内容真的是很全面了，各种的资源都有，哈哈哈</p>
<img src="https://i.loli.net/2021/04/30/ziwFcNfbSe7yKQu.png" width="50%" height="50%">

<p>笔者初始ipa包大小为22.9M，解压缩之后.app的大小为57.1M，其中各部分大小明细如下</p>
<table>
<thead>
<tr>
<th align="center">内容</th>
<th align="center">大小</th>
</tr>
</thead>
<tbody><tr>
<td align="center">_CodeSignature</td>
<td align="center">93 KB</td>
</tr>
<tr>
<td align="center">.lproj</td>
<td align="center">4 KB</td>
</tr>
<tr>
<td align="center">Frameworks</td>
<td align="center">37.5 MB</td>
</tr>
<tr>
<td align="center">Plugins</td>
<td align="center">181 KB</td>
</tr>
<tr>
<td align="center">Assets.car</td>
<td align="center">4.9M</td>
</tr>
<tr>
<td align="center">embedded.mobileprovision</td>
<td align="center">8KB</td>
</tr>
<tr>
<td align="center">Info.plist</td>
<td align="center">6 KB</td>
</tr>
<tr>
<td align="center">exec格式的xxx</td>
<td align="center">13 MB</td>
</tr>
<tr>
<td align="center">其它资源文件</td>
<td align="center">1.4 MB</td>
</tr>
</tbody></table>
<p>了解了iPa包的组成之后，我们再回过头来，按照Xcode的编译优化、资源文件优化、代码优化的步骤来一步步分析。</p>
<h3 id="Xcode编译设置"><a href="#Xcode编译设置" class="headerlink" title="Xcode编译设置"></a>Xcode编译设置</h3><p>一般这一步容易被人忽略，因为提到优化最先能想到的就是资源优化，比如图片压缩、无用代码删除等等，而对于Xcode自身的编译优化提及的反而不多。而且由于网上提供的参考针对每个项目可能结果都不一样，有些编译选项的设置是需要针与实际项目结合起来才可以，所以笔者这里整理和总结了一下：</p>
<p>Xcode编译优化相关：</p>
<ol>
<li><p>Build Settings中去掉异常支持，Enable C++ Exceptions和Enable Objective-C Exceptions设置为NO，Other C Flags添加-fno-exceptions；</p>
<p> <img src="https://i.loli.net/2021/04/30/T9tzQUMnNvY8dIa.png" alt="WeCom20210430-150019.png"></p>
<p> <img src="https://i.loli.net/2021/04/30/XnUw45j9mvSqAFb.png" alt="WeCom20210430-150116.png"></p>
<p> 注意：Enable C++ Excptions和Enable Objective-C Exceptions是指项目支持对错误的异常处理，比如try catch、throw之类的；所以如果项目中使用的有类似的异常处理的，这个关闭了之后会报错（Cannot use ‘@try’ with Objective-C exceptions disabled）。包括宏定义中使用的有try{}、@finally{}之类的，比如@strongify等，如果关闭了最后打包的时候也会报错。</p>
<p> -fno-exceptions的意思是禁用异常机制，参考<a target="_blank" rel="noopener" href="http://gcc.gnu.org/onlinedocs/gcc-4.7.0/libstdc++/manual/manual/using_exceptions.html">gcc</a>，同样，当项目中有try thorw的时候，就不要设置这个选项为NO</p>
<blockquote>
<p>Before detailing the library support for -fno-exceptions, first a passing note on the things lost when this flag is used: it will break exceptions trying to pass through code compiled with -fno-exceptions whether or not that code has any try or catch constructs. If you might have some code that throws, you shouldn’t use -fno-exceptions. If you have some code that uses try or catch, you shouldn’t use -fno-exceptions.</p>
</blockquote>
</li>
<li><p>Build Settings -&gt; Architectures，Release下设置为arm64</p>
<p> <img src="https://i.loli.net/2021/04/30/ni98fbkxzMqhH3N.png" alt="WeCom20210430-170718@2x.png"></p>
<p> Architectures指定工程被编译成可支持哪些指令集类型，支持的指令集越多，就会编译出多个指令集代码的数据包，ipa包就会变大。默认的standard architectures(armv7,arm64) 参数，打的包里面有32位、64位两份指令集。如果不需要32位的，可以在other中更改支持的指令集，从而使ipa包变小。</p>
<blockquote>
<p>armv6: iPhone, iPhone 3G, iPod 1G/2G<br>armv7: iPhone 3GS, iPhone 4, iPhone 4S, iPod 3G/4G/5G, iPad, iPad 2, iPad 3, iPad Mini<br>armv7s: iPhone 5, iPhone 5c, iPad 4<br>arm64: iPhone X，iPhone 8(Plus)，iPhone 7(Plus)，iPhone 6(Plus)，iPhone 6s(Plus), iPhone 5s, iPad Air(2), Retina iPad Mini(2,3)<br>arm64e: XS/XS Max/XR/ iPhone 11, iPhone 11 pro<br>x86_64: 模拟器64位处理器<br>i386: 模拟器32位处理器</p>
</blockquote>
<p> 注意：Xcode 12之后，没有了Valid Architectures选项的设置。<br> 另：如果把Architectures从standard architectures(armv7,arm64)改为arm64，则会发现target无法选择模拟器运行了，所以建议Debug模式下修改为arm64、x86_64或者不修改，Release下设置为arm64。</p>
<p> 更新：经朋友指点，这个地方Architectures的设置，还有另外一种设置方法，Architectures不修改，Excluded Architectures中设置Release模式下 <strong>Any iOS SDK</strong> -&gt; armv7，也可以实现同样的效果。设置了之后，就是Release下把armv7的指令集排除在外。选中target会发现默认设置了 <strong>Any iOS Simulator SDK</strong> -&gt; arm64，意思是模拟器的时候排除arm64指令集。</p>
<p> 如下：</p>
<p> <img src="https://i.loli.net/2021/05/08/zBHAX8Wxf6Jt1np.png" alt="WX20210508-162103.png"></p>
</li>
</ol>
<ol start="3">
<li><p>Build Settings -&gt; Generate Debug Symbols设置为NO</p>
<p> <img src="https://i.loli.net/2021/04/30/N6csAHg4m2MrtFo.png" alt="WeCom20210430-152121.png"></p>
<p> Generate Debug Symbols的意思是生成调试符号，当这个选项设置为YES时，每个源文件在编译成.o文件时，编译参数多了-g和-gmodule，意思是generate complete debug info，所以产生的.o文件会大，从而最终生成的可执行文件也就会变大。</p>
<blockquote>
<p>Generate Debug Symbols (GCC_GENERATE_DEBUGGING_SYMBOLS), Enables or disables generation of debug symbols. When debug symbols are enabled, the level of detail can be controlled by the Debug Information Format (DEBUG_INFORMATION_FORMAT) setting.</p>
</blockquote>
<p> 注意Generate Debug Symbols设置为NO时，在Xcode中设置的断点不会中断，即不能断点调试。且最后不能生成DSYM文件，即使Debug Information Format设置了，也不能生成，因为首先要有调试信息然后才能生成DSYM文件，而设置为NO，意味着不产生调试信息，所以也就没办法生成DSYM文件。所以建议不要设置。</p>
</li>
<li><p>Build Settings -&gt; Deployment Postprocessing，Debug模式下设置NO，Release下设为YES</p>
<p> Deployment Postprocessing是Strip配置的总开关</p>
<p> <img src="https://i.loli.net/2021/04/30/TUy7AC8FhEYqHI6.png" alt="WeCom20210430-171159@2x.png"></p>
<p> <a target="_blank" rel="noopener" href="https://help.apple.com/xcode/mac/11.4/#/itcaec37c2a6">官方解释：</a></p>
<blockquote>
<p>Deployment Postprocessing (DEPLOYMENT_POSTPROCESSING), If enabled, indicates that binaries should be stripped and file mode, owner, and group information should be set to standard values.</p>
</blockquote>
<p> 注意：Deployment Postprocessing是Strip配置的总开关，只有这个设置为YES之后，下面的Strip Linked Product、Strip Debug Symbols During Copy的设置才会生效。</p>
<ol>
<li><p>Build Settings -&gt; Strip Linked Product，Debug下设置为NO，Release下设置为YES</p>
<p>  对最后生成的二进制文件进行strip，去除不必要的符号信息，Release下可以为YES。</p>
<p>  <a target="_blank" rel="noopener" href="https://help.apple.com/xcode/mac/11.4/#/itcaec37c2a6">官方解释：</a></p>
<blockquote>
<p>Strip Linked Product (STRIP_INSTALLED_PRODUCT), If enabled, the linked product of the build will be stripped of symbols when performing deployment postprocessing.</p>
</blockquote>
<p>  注意：如果Deployment Postprocessing不打开，该选项没有作用。去除了符号信息之后需要使用dSYM来进行符号化，所以需要将 Debug Information Format 修改为DWARF with dSYM file（Release下），如果在Debug下设置为DWARF with dSYM file那么在崩溃时将无法看到堆栈信息。</p>
</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>Build Settings -&gt; Strip Debug Symbols During Copy，Debug下设置为NO，Release下设置为YES</p>
<p>  文件拷贝编译阶段是否进行strip，设置为YES之后，会把拷贝进项目包的三方库、资源或者Extension的Debug Symbol去除。</p>
<p>  <a target="_blank" rel="noopener" href="https://help.apple.com/xcode/mac/11.4/#/itcaec37c2a6">官方解释：</a></p>
<blockquote>
<p>Strip Debug Symbols During Copy (COPY_PHASE_STRIP), Specifies whether binary files that are copied during the build, such as in a Copy Bundle Resources or Copy Files build phase, should be stripped of debugging symbols. It does not cause the linked product of a target to be stripped—use Strip Linked Product (STRIP_INSTALLED_PRODUCT) for that.</p>
</blockquote>
<p>  注意：如果Deployment Postprocessing不打开，该选项没有作用</p>
</li>
<li><p>Build Settings -&gt; Symbols Hidden by Default，Debug模式下设置为NO，Release下设置为YES</p>
<p>  <img src="https://i.loli.net/2021/04/30/kIpZyLsNw3Vi8R6.png" alt="WeCom20210430-171411@2x.png"></p>
<p>  Symbols Hidden by Default会把所有符号都定义成”private extern”，移除符号信息</p>
<p>  <a target="_blank" rel="noopener" href="https://help.apple.com/xcode/mac/11.4/#/itcaec37c2a6">官方解释：</a></p>
<blockquote>
<p>Symbols Hidden by Default (GCC_SYMBOLS_PRIVATE_EXTERN), When enabled, all symbols are declared private extern unless explicitly marked to be exported using <strong>attribute</strong>((visibility(“default”))) in code. If not enabled, all symbols are exported unless explicitly marked as private extern. See Controlling Symbol Visibility in C++ Runtime Environment Programming Guide.</p>
</blockquote>
</li>
<li><p>Build Settings -&gt; Make Strings Read-Only设置为YES</p>
<p> <img src="https://i.loli.net/2021/04/30/umHf4RCtFqj2JhN.png" alt="WeCom20210430-171444@2x.png"></p>
<p> 复用字符串字面量</p>
<p> <a target="_blank" rel="noopener" href="https://help.apple.com/xcode/mac/11.4/#/itcaec37c2a6">官方解释：</a></p>
<blockquote>
<p>Make Strings Read-Only (GCC_REUSE_STRINGS), Reuse string literals.</p>
</blockquote>
</li>
<li><p><font color='Gold'>Build Settings -&gt; Dead Code Stripping设置为YES</font></p>
<p> <img src="https://i.loli.net/2021/05/10/DXVHEc3dgP5OhNR.png" alt="WX20210510-131729.png"></p>
<p> 消除无效代码，C/C++/Swift 等静态语言编译器会在 link 的时候移除未使用的代码，对于OC等动态语言是无效的</p>
<p> <a target="_blank" rel="noopener" href="https://help.apple.com/xcode/mac/11.4/#/itcaec37c2a6">官方解释：</a></p>
<blockquote>
<p>Dead Code Stripping (DEAD_CODE_STRIPPING), Activating this setting causes the -dead_strip flag to be passed to ld(1) via cc(1) to turn on dead code stripping.</p>
</blockquote>
</li>
<li><p><font color='Gold'>Pod优化</font>，如果项目是OC的，但CocoaPod中有使用了Swift库，打开了use_frameworks!，可以优化为针对单个Swift库使用use_frameworks!而不是全部第三方库都使用。代码如下：</p>
 <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Podfile</span></span><br><span class="line"><span class="comment"># 下面的这行代码还是打开，不需要注释掉</span></span><br><span class="line">  use_frameworks!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 之前的其它代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后添加下面的代码，xxx是要打包成framework的库</span></span><br><span class="line">dynamic_frameworks = [<span class="string">&#x27;xxx&#x27;</span>]</span><br><span class="line">pre_install <span class="keyword">do</span> <span class="params">|installer|</span></span><br><span class="line">    installer.pod_targets.each <span class="keyword">do</span> <span class="params">|pod|</span></span><br><span class="line">        <span class="keyword">if</span> !dynamic_frameworks.<span class="keyword">include</span>?(pod.name)</span><br><span class="line">            def pod.static_framework?;</span><br><span class="line">             <span class="literal">true</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            def pod.build_type;</span><br><span class="line">                Pod::BuildType.static_library</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 在OC的项目中，Podfile如果引用了Swift的第三方库，一般都会直接打开use_frameworks!，对应的Pod中所有的库都会打包成动态库，以及Swift和OC库的依赖问题会导致依赖库增加，会造成包体积增大。</p>
<p> 修改方法有两种：</p>
<ul>
<li>去除依赖的Swift第三方库，找对应的OC库替代；</li>
<li>通过Podfile里hook的方式，改动态库为静态库</li>
</ul>
<p> 这两种修改方法都可以显著减小包的体积。通过替代库可避免导入Swift相关的依赖基础库，且对应的use_frameworks!可以注释掉，相对来说，包会更小，但是改动比较大，需要把之前的库替换掉。而通过hook的方式，针对个别的库打包成动态库，其余的打包成静态库，项目修改比较小，包体积也能减小。具体采用哪种视具体项目情况而定。</p>
</li>
</ol>
<pre><code>注意：Podfile按照上面的修改了之后，需要重新使用Pod install命令更新，然后编译时可能会有报错。

1. 如果报的错误是，&#39;RuntimeError - [Xcodeproj] Consistency issue: build setting `ARCHS` has multiple values: `&#123;&quot;Debug&quot;=&gt;&quot;$(ARCHS_STANDARD)&quot;, &quot;Release&quot;=&gt;[&quot;arm64&quot;]&#125;`&#39;，可以先把Architecture中的值改为一样的，Pod install之后再改为不同指令集的。
2. 因为之前第三方库打包成framework的问题，如果遇到xxx framework not found的错误，在Build Setting中Other Linker Flags中进行修改，把对应的已经不是framework的库从其中移除即可。示例如下：

&lt;img src=&quot;https://i.loli.net/2021/05/01/KBS9c6D8oVFYUsW.png&quot; width=&quot;50%&quot; height=&quot;50%&quot;&gt;
</code></pre>
<ol start="8">
<li><p><font color='Gold'>Asset Catalog Compiler编译设置优化</font>，Build Settings -&gt; Asset Catalog Compiler - Options 中Optimization改为space</p>
<p> <img src="https://i.loli.net/2021/05/06/QOc6tvHCXjz7Sse.png" alt="WX20210506-100606.png"></p>
<p> 这个选项可以改变actool在构建Assets.car时选取的编码压缩算法，减少包大小。可以使用下面的命令检查Assets.car中图片的编码压缩算法。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 可以把对应信息生成.json文件，用于对比不同</span><br><span class="line"> xcrun --sdk iphoneos assetutil --info Assets.car &gt; Assets.json</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 比如笔者的设置了之后，对比查看信息如下，可发现压缩的算法不同，占用空间的大小也不同</p>
 <img src="https://i.loli.net/2021/05/06/3fxO2lCLb8nEMra.png" width="70%" height="50%"></li>
<li><p>Build Settins -&gt; Optimization Level改为-Oz</p>
<p> <img src="https://i.loli.net/2021/05/06/WrbMZpg7zj5sB83.png" alt="WX20210506-140136.png"></p>
<p> Optimization Level默认为-Os，-Oz是Xcode 11之后才出现的编译优化选项，核心原理是对重复的连续机器指令外联成函数进行复用，因此开启Oz，能减少二进制的大小，但同时会带来执行效率但额外消耗。可参考<a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2019/409/">What’s New in Clang and LLVM</a></p>
<p> 在<a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2019/409/">What’s New in Clang and LLVM</a>的Presentation Slides中，苹果给出了Optimization Level各参数优化的选择对比，如下图，对于性能要求高的，建议选择-O2和-O3，对于包大小敏感的，可选择-Os和-Oz，默认-Os是性能和大小平衡比较好的。最终选择什么，需要读者根据自己实际项目而定。</p>
 <img src='https://i.loli.net/2021/05/06/jvVrKUpMNRXOqGC.png' width="70%" height="60%">

<p> Optimization Level各参数对比：</p>
<p> <a target="_blank" rel="noopener" href="https://help.apple.com/xcode/mac/11.4/#/itcaec37c2a6">官方解释：</a></p>
<blockquote>
<p>Smallest, Aggressive Size Optimizations: This setting enables additional size savings by isolating repetitive code patterns into a compiler generated function. -Oz</p>
</blockquote>
 <img src='https://i.loli.net/2021/05/06/alvWVYtD8MsQu3m.png' width="70%" height="60%"></li>
</ol>
<h4 id="Xcode编译设置优化总结如下："><a href="#Xcode编译设置优化总结如下：" class="headerlink" title="Xcode编译设置优化总结如下："></a>Xcode编译设置优化总结如下：</h4><p><strong>优化结果</strong></p>
<p>笔者最初项目大小最初为22.9M，设置了Pod优化之后大小缩减为21M，设置了Asset Catalog Compiler - Options 中Optimization为space之后，项目大小变为20.7M，再设置了上面其它Xcode编译优化之后，项目变为13.2M（笔者把Architecture设为arm64）</p>
<p><strong>设置Pod优化之后各部分对比</strong></p>
<table>
<thead>
<tr>
<th align="center">内容</th>
<th align="center">大小</th>
</tr>
</thead>
<tbody><tr>
<td align="center">_CodeSignature</td>
<td align="center">67 KB</td>
</tr>
<tr>
<td align="center">.lproj</td>
<td align="center">4 KB</td>
</tr>
<tr>
<td align="center">Frameworks</td>
<td align="center"><font color='red'>21.4 MB</font></td>
</tr>
<tr>
<td align="center">Plugins</td>
<td align="center">181 KB</td>
</tr>
<tr>
<td align="center">Assets.car</td>
<td align="center">4.9M</td>
</tr>
<tr>
<td align="center">embedded.mobileprovision</td>
<td align="center">8KB</td>
</tr>
<tr>
<td align="center">Info.plist</td>
<td align="center">6 KB</td>
</tr>
<tr>
<td align="center">exec格式的xxx</td>
<td align="center"><font color='red'>19.2 MB</font></td>
</tr>
<tr>
<td align="center">其它资源文件</td>
<td align="center">1.4 MB</td>
</tr>
</tbody></table>
<p>简单对比大小之后可以发现，Frameworks从35M减少到了21.4M，而exec文件从13M升到了19.2M，但总的ipa包大小变为了21M，比之前但22.9M降低了。</p>
<p>为什么会这样呢？还记得Frameworks文件夹里放的是什么内容吗？Framework中放的Pod中设置的第三方的动态库、以及Swift Support库。仔细观察Frameworks文件夹中的内容，可以发现，之前在这里面的第三方的.framework，除了指定的打包成动态库的第三方xxx、和Swift Support库还在，其他的都不见了。</p>
<p>还记得笔者改的是什么吗？笔者把Pod中第三方库从都使用动态库改为了个别使用动态库、其它使用静态库。因为动态库和静态库链接的方式的不同，<strong>动态库链接时不复制，在程序启动后用动态加载</strong>，所以是单独放在Framework文件夹下；而静态库是<strong>链接时会被完整的复制到可执行文件中</strong>。所以，于是就出现了这样的结果，Frameworks文件大小减少，而可执行文件大小增加。</p>
<p><strong>设置了Asset Catalog Compiler - Options 中Optimization为space后对比</strong></p>
<table>
<thead>
<tr>
<th align="center">内容</th>
<th align="center">大小</th>
</tr>
</thead>
<tbody><tr>
<td align="center">_CodeSignature</td>
<td align="center">67 KB</td>
</tr>
<tr>
<td align="center">.lproj</td>
<td align="center">4 KB</td>
</tr>
<tr>
<td align="center">Frameworks</td>
<td align="center">21.4 MB</td>
</tr>
<tr>
<td align="center">Plugins</td>
<td align="center">181 KB</td>
</tr>
<tr>
<td align="center">Assets.car</td>
<td align="center"><font color='red'>4.7M</font></td>
</tr>
<tr>
<td align="center">embedded.mobileprovision</td>
<td align="center">8KB</td>
</tr>
<tr>
<td align="center">Info.plist</td>
<td align="center">6 KB</td>
</tr>
<tr>
<td align="center">exec格式的xxx</td>
<td align="center">19.2 MB</td>
</tr>
<tr>
<td align="center">其它资源文件</td>
<td align="center">1.4 MB</td>
</tr>
</tbody></table>
<p>对比之后发现，Assets.car中大小从4.9M减少到了4.7M，总的打包出来的ipa大小减少了0.3M，说明asset压缩有效。</p>
<p><strong>设置了Optimization Level为-Oz后对比</strong></p>
<table>
<thead>
<tr>
<th align="center">内容</th>
<th align="center">大小</th>
</tr>
</thead>
<tbody><tr>
<td align="center">_CodeSignature</td>
<td align="center">67 KB</td>
</tr>
<tr>
<td align="center">.lproj</td>
<td align="center">4 KB</td>
</tr>
<tr>
<td align="center">Frameworks</td>
<td align="center">21.4 MB</td>
</tr>
<tr>
<td align="center">Plugins</td>
<td align="center">181 KB</td>
</tr>
<tr>
<td align="center">Assets.car</td>
<td align="center">4.7M</td>
</tr>
<tr>
<td align="center">embedded.mobileprovision</td>
<td align="center">8KB</td>
</tr>
<tr>
<td align="center">Info.plist</td>
<td align="center">6 KB</td>
</tr>
<tr>
<td align="center">exec格式的xxx</td>
<td align="center"><font color='red'>18.9 MB</font></td>
</tr>
<tr>
<td align="center">其它资源文件</td>
<td align="center">1.4 MB</td>
</tr>
</tbody></table>
<p>对比之后发现，exec的可执行文件大小从19.2M减少到了18.9M，说明优化有效，但总的打包出来的ipa大小并没有改变（上传到fir后，包小了0.03M），故而最终这个选项笔者最终没有打开。</p>
<p><strong>Xcode其它编译设置优化之后对比</strong></p>
<table>
<thead>
<tr>
<th align="center">内容</th>
<th align="center">大小</th>
</tr>
</thead>
<tbody><tr>
<td align="center">_CodeSignature</td>
<td align="center">67 KB</td>
</tr>
<tr>
<td align="center">.lproj</td>
<td align="center">4 KB</td>
</tr>
<tr>
<td align="center">Frameworks</td>
<td align="center"><font color='red'>11.1 MB</font></td>
</tr>
<tr>
<td align="center">Plugins</td>
<td align="center"><font color='red'>83 KB</font></td>
</tr>
<tr>
<td align="center">Assets.car</td>
<td align="center">4.7M</td>
</tr>
<tr>
<td align="center">embedded.mobileprovision</td>
<td align="center">8KB</td>
</tr>
<tr>
<td align="center">Info.plist</td>
<td align="center">6 KB</td>
</tr>
<tr>
<td align="center">exec格式的xxx</td>
<td align="center"><font color='red'>10.3 MB</font></td>
</tr>
<tr>
<td align="center">其它资源文件</td>
<td align="center">1.4 MB</td>
</tr>
</tbody></table>
<p>简单对比大小之后可以发现，Frameworks从21.4M减少到了11.1M，Plugins从181KB减少到了83KB，exec文件也从19.2M减少到了10.3M。</p>
<p>同样为什么会这样呢？笔者设置了strip移除了符号信息，设置了打包只生成arm64架构指令集的包，所以Framework和exec都变小了，那Plugin呢？Plugin中是App创建的扩展，笔者针对通知扩展，也设置了只生成arm64指令集的包，所以Plugin也变小了。</p>
<p><strong>优化总结</strong></p>
<p><img src="https://i.loli.net/2021/05/08/mYLJC7AuPRBwpGo.png" alt="WX20210508-162503.png"></p>
<p>也许有人觉得笔者目前项目包没有太大，做这个优化是否有意义？在笔者看来，包大小优化应该是习惯，不是因为包大了才去优化，而是因为觉得有优化空间，所以才优化。打包出来ipa的包小，说明历史负担不重，船小好调头，编译打包速度也快，而且试错成本也低，恰恰是正应该优化的时候。优化总结出来的经验教训，落入文档，后续开发时能时刻注意，对开发来说是更好的。</p>
<h3 id="资源文件优化"><a href="#资源文件优化" class="headerlink" title="资源文件优化"></a>资源文件优化</h3><p>资源文件的优化，通常来说是比较简单的，但是资源文件的优化是需要持续进行的，前面介绍的Xcode编译设置优化，配置好了之后，后续开发过程中只要不修改配置，都无需重复关注。但资源文件不同，随着项目的迭代，会不断引入新的资源文件，不断有废弃资源的产生，所以资源文件的优化是要持续进行的。</p>
<p>资源文件的优化分为两部分，即：无用资源的删除、已用资源的压缩。在这里建议分先后顺序，即先做删除再做压缩，因为如果先压缩了，结果发现是无用资源，就白白浪费了力气。</p>
<p>无用资源的删除：</p>
<ul>
<li>已定义未使用的代码文件</li>
<li>已废弃业务，代码还在</li>
<li>已引用的图片但未使用</li>
<li>某些重复资源导入</li>
</ul>
<p>已用资源的压缩：</p>
<ul>
<li>项目中引入图片、网页、json、音频等文件的压缩</li>
</ul>
<p>下面一步步的来实践：</p>
<h4 id="无用资源的删除"><a href="#无用资源的删除" class="headerlink" title="无用资源的删除"></a>无用资源的删除</h4><p>随着项目的迭代，每个项目都会或多或少存在冗余。可能是开发了的功能未上线但产品让保留，保留着保留着就忘记了；可能是已下线的业务，没人通知到开发，于是代码逻辑一直都在；可能是删除某些业务代码时，对应的图片资源未删除；又或者是每个开发，导入各自熟悉的第三方库使用。</p>
<p>这部分的优化在笔者看来，也分为两步，一是预防，一是治理。笔者个人感觉预防比治理更重要。因为预防是前置，预防到位了，治理就会很轻松。</p>
<p><strong>预防</strong></p>
<p>上面说的场景，读者可能都遇到过，那要怎么做才能避免出现上面的情况，或者尽量少出现上面的情况？</p>
<p>笔者个人想法是通过规范的流程来，有一套规范的流程，按流程执行，避免出现信息不对等的情况。</p>
<p>产品和开发之间的信息不对等，会导致业务相关的冗余，产品知道具体业务的数据，而开发不清楚，所以可以通过定期同步给开发，让开发也能了解到对应业务是否活跃，从而及时对项目进行优化。</p>
<p>开发之间的信息不对等，会导致各自开发自己的，重复造轮子，所以可以通过建立公共文档，开发的流程规范、项目使用第三方库的规范、设计规范、代码规范都列举出来，每个人都能根据对应的文档了解到对应项目的信息，每个人开发都应该有一套统一的标准。这样就可以避免一人一套代码的问题。</p>
<p>具体的规范流程读者可以针对自己公司的实际情况来，可以思考一下，之前开发中是否出现了类似的问题，出现了之后是否有改变，怎么能避免再次出现同样的问题？</p>
<p><strong>治理</strong></p>
<p>针对无用资源的删除</p>
<ul>
<li><p>已定义未使用的代码</p>
<p>  可使用AppCode进行分析，打开AppCode，待索引完成后，选择顶部菜单中的Code-&gt;Inspect Code，然后选择范围，whole Project点击OK，等待AppCode静态分析即可。静态分析完以后，可以在Unused code里看到所有的无用代码。</p>
  <img src="https://i.loli.net/2021/05/05/qvHd3ODLcE1pf2n.png" width="50%" height="50%"></li>
</ul>
<pre><code>&lt;img src=&quot;https://i.loli.net/2021/05/05/jwpaohKbyqcxI9v.png&quot; width=&quot;50%&quot; height=&quot;50%&quot;&gt;

AppCode中无用代码静态分析的类型有以下几种： 

| 内容 | 大小 |
| :----: | :----: |
| Unused class |   无用类 |
| Unused import statement |   无用类引入声明 |
| Unused property |  无用属性 |
| Unused method |   无用方法 |
| Unused parameter |   无用参数 |
| Unused instance variable |   无用实例变量 |
| Unused local variable |   无用局部变量 |
| Unused value |   无用值声明 |
| Unused macro |   无用宏定义 |
| Unused global declaration |   无用全局证明 |

AppCode静态分析结果出来之后，删除前要经过确认，因为静态分析的结果可能会有误差，比如针对performSelector调用的方法就会被检测为没有调用。
</code></pre>
<ul>
<li>已废弃业务，代码还在  需要梳理业务流程，结合线上业务数据点击量，同产品和业务确认对应功能是否下线，从而决定是否移除对应的业务模块代码。</li>
</ul>
<ul>
<li>已引入未使用图片</li>
</ul>
<pre><code>推荐使用工具[LSUnusedResources](https://github.com/tinymind/LSUnusedResources)，原理大致是遍历资源目录下后缀 [&quot;imageset&quot;, &quot;jpg&quot;, &quot;png&quot;...] 的文件，然后在源文件 [&quot;m&quot;, &quot;swift&quot;, &quot;xib&quot;, &quot;storyboard&quot;...] 中字符串匹配，无匹配则是无用的资源文件。

使用时注意勾选Ignore similar name，然后点击右上角的Browse选中要扫描的项目地址，点击右下角的search，就会开始扫描，结果会在底部Unused Results中展示出来，然后CMD+A全选，export，导出到一个文本文件中。也可以在对应单条Item上面双击，会打开对应的文件夹。建议删除前在项目中搜索确认，是否确实没有使用（类似字符串中间替换的可能会被扫描出来，所以删除前需要确认）

&lt;img src=&quot;https://i.loli.net/2021/05/01/qdguJoHpK6IybhZ.png&quot; width=&quot;50%&quot; height=&quot;50%&quot;&gt;
</code></pre>
<ul>
<li><p>某些重复资源的导入</p>
<p>  重复资源的导入，分为两个方面，一方面是针对第三方SDK，另一方面是项目文件。</p>
<ul>
<li><p>针对第三方SDK</p>
<p>  项目中功能类似的SDK建议保留一个，比如埋点统计的友盟、TalkingData等，线上日志分析的听云、Bugly等，又或者网络请求、UI布局的类库，建议分析相同功能的类库，结合实际情况，保留一个即可；另外，有些第三方类库导入时，可只导入实际使用的部分，不需全量导入，也是可以优化的地方。</p>
</li>
<li><p>针对项目文件</p>
<p>  使用 fdupes 工具进行重复文件扫描，原理是：通过校验所有资源的 MD5，筛选出项目中的重复资源，文件比较顺序是大小对比 &gt; 部分 MD5 签名对比 &gt; 完整 MD5 签名对比 &gt; 逐字节对比。来自：<a target="_blank" rel="noopener" href="https://www.zybuluo.com/qidiandasheng/note/1662385">包体积大小：瘦身</a></p>
<p>  fdupes使用如下：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 1. 首先安装fdupes</span><br><span class="line">brew install fdupes</span><br><span class="line"></span><br><span class="line">// 2. 使用，其中xxx是要扫描的目录，yyy.txt是扫描结果输出的文件</span><br><span class="line">fdupes -Sr /Users/.../xxx/ &gt; /Users/.../yyy.txt </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  输出结果类似于下面这样，通常相同文件可通过修改引用，仅保留一份源文件就可以。</p>
<p>  <img src="https://i.loli.net/2021/05/05/bjPfg8uoNXqAEDB.png" alt="WX20210505-103131@2x.png"></p>
</li>
</ul>
</li>
</ul>
<h4 id="已用资源的压缩"><a href="#已用资源的压缩" class="headerlink" title="已用资源的压缩"></a>已用资源的压缩</h4><ul>
<li><p>项目中引入图片、网页、json、音频等文件的压缩</p>
<p>  网页的压缩指的是，放入APP资源中的js文件，最好是经过H5端压缩后的。</p>
<p>  json文件的压缩，如果不是打开APP时马上要用到的数据，可采取把对应资源放到服务端，下载后使用。</p>
<p>  音频文件的压缩，则是在可接受的范围之内，选择系统可支持的压缩比率高的格式。</p>
<p>  而最需要注意的是图片的压缩，图片的压缩，分为几个部分</p>
<ol>
<li><p>单色图标、简单的功能图标，建议使用IconFont，矢量图标库的格式，既能统一规范格式，又能减少资源文件大小。圆角和阴影图片尽量代码实现。</p>
<p> IconFont的使用可参考笔者之前写的Demo——<a target="_blank" rel="noopener" href="https://github.com/mokong/IconFont">IconFont</a></p>
</li>
<li><p>针对普通图片，可以调用tinyPNG API进行压缩，这里可以使用笔者之前修改的脚本<a target="_blank" rel="noopener" href="https://github.com/mokong/BatchProcessImage">BatchProcessImage</a>，调用的是tinyPNG的API可以一次性压缩500张图片，而且只需要指定项目目录，会自动压缩后替换原来的图片，不需要手动导入导出图片。使用可参考链接<a target="_blank" rel="noopener" href="https://github.com/mokong/BatchProcessImage">BatchProcessImage</a>，需要注意的是注意python版本，python3和python，以及pip3和pip的选择，安装依赖库的时候使用的哪个python版本，最后调用的脚本命令的时候就要用对应的python版本。</p>
<p> 另：如果项目图片超出500张，可以修改一下脚本文件，即：压缩过程中把压缩处理过的图片存储下来，然后第二次执行时，对于压缩过的不处理，就可以接着上次压缩到的继续压缩了。而如果需要对压缩过的再次压缩，只需要把存储下来的压缩过的图片名字清除即可。</p>
</li>
<li><p>放入xcassets里的2x和3x图片，在上传时，会根据具体设备分开对应分辨率的图片，不会同时包含。而放入Bundle中的都会包含。所以要尽量把图片放入xcassets中。但是，根据<a target="_blank" rel="noopener" href="https://blog.csdn.net/ByteDanceTech/article/details/112504772">抖音品质建设 - iOS 安装包大小优化实践篇</a>中介绍的，Assets.car编译过程中有时会选择一些图片，拼凑成一张大图来提高图片的加载效率。被放进这张大图的小图会变为通过偏移量的引用，建议使用频率高且小的图片放到Asset.car中，Asset.car能保证加载和渲染速度最优。但是大的图片（大于100K）就不要放入Asset.car中了。大的图片可以考虑将图片转成<a target="_blank" rel="noopener" href="https://developers.google.com/speed/webp/docs/using">WebP</a>。<a target="_blank" rel="noopener" href="https://developers.google.com/speed/webp/docs/using">WebP</a>是Google公司的一个开源项目，能够把图片压缩到很小，但是肉眼看不出来差别，目前iOS常用的图片显示类库都用支持该格式解析的拓展。可使用<a target="_blank" rel="noopener" href="http://isparta.github.io/">iSparta</a>进行批量转换。</p>
</li>
<li><p>私有Pod库中的资源文件，建议在Pod库里面的Resource目录下新建Asset Catalog文件，命名为Images.xcassets，私有库使用的图片放入这里，然后手动修改该SDK的podspec，指定resource_bundles使用Images.xcassets。</p>
 <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">s.resource_bundles = &#123;</span><br><span class="line">    <span class="string">&#x27;xxsdk&#x27;</span> =&gt; [<span class="string">&#x27;xxx/Assets/.../*.xcassets&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> Ps: Pod资源文件引用方式有 resource_bundles 和 resources，推荐使用 resource_bundles。参考<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904169938092045#heading-15">深入探索 iOS 包体积优化</a></p>
<ul>
<li><p>resource_bundles：允许定义当前 Pod 库的资源包的名称和文件。用 hash 的形式来声明，key 是 bundle 的名称，value 是需要包括的文件的通配 patterns。CocoaPods 官方强烈推荐使用 resource_bundles，因为用 key-value 可以避免相同名称资源的名称冲突。同时建议 bundle 的名称至少应该包括 Pod 库的名称，可以尽量减少同名冲突。使用resource_bundles会为指定的资源打一个.bundle，所以获取图片时要注意指定bundle的位置：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NSString *bundlePath = [[NSBundle bundleForClass:[self class]].resourcePath stringByAppendingPathComponent:@&quot;/PAX.bundle&quot;];</span><br><span class="line">NSBundle *resource_bundle = [NSBundle bundleWithPath:bundlePath];</span><br><span class="line">UIImage *image = [UIImage imageNamed:@&quot;xxxx&quot; inBundle:resource_bundle compatibleWithTraitCollection:nil];</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>resources：使用 resources 来指定资源，被指定的资源只会简单的被 copy 到目标工程中（主工程）。官方认为用 resources 是无法避免同名资源文件的冲突的，同时，Xcode 也不会对这些资源做优化。</p>
</li>
</ul>
</li>
<li><p>最后，是Xcode中关于图片压缩的设置，有时候压缩了图片之后，发现包大小并没有改变太多，可能是因为Xcode的Compress PNG Files选项的原因。建议如果自己对图片进行了压缩，就可以把Xcode的Compress PNG Files设置为NO。 </p>
<ul>
<li><p>Compress PNG Files<br>打包的时候自动对图片进行无损压缩</p>
</li>
<li><p>Remove Text Medadata From PNG Files<br>移除 PNG 资源的文本字符</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="资源文件优化总结如下："><a href="#资源文件优化总结如下：" class="headerlink" title="资源文件优化总结如下："></a>资源文件优化总结如下：</h4><p><strong>优化结果</strong></p>
<p>笔者项目的ipa大小从Xcode编译优化后的大小为13.2M，经过了资源文件优化之后大小缩减为10.3M。</p>
<p><strong>资源文件优化之后各部分对比</strong></p>
<table>
<thead>
<tr>
<th align="center">内容</th>
<th align="center">大小</th>
</tr>
</thead>
<tbody><tr>
<td align="center">_CodeSignature</td>
<td align="center">67 KB</td>
</tr>
<tr>
<td align="center">.lproj</td>
<td align="center">4 KB</td>
</tr>
<tr>
<td align="center">Frameworks</td>
<td align="center">11.1 MB</td>
</tr>
<tr>
<td align="center">Plugins</td>
<td align="center">83 KB</td>
</tr>
<tr>
<td align="center">Assets.car</td>
<td align="center"><font color='red'>2.4M</font></td>
</tr>
<tr>
<td align="center">embedded.mobileprovision</td>
<td align="center">8KB</td>
</tr>
<tr>
<td align="center">Info.plist</td>
<td align="center">6 KB</td>
</tr>
<tr>
<td align="center">exec格式的xxx</td>
<td align="center">10.3 MB</td>
</tr>
<tr>
<td align="center">其它资源文件</td>
<td align="center"><font color='red'>952 KB</font></td>
</tr>
</tbody></table>
<p>简单对比之后发现，Assets.car从4.7M减少到2.4M，其它资源文件从1.4M减少到952KB，说明资源压缩有效。</p>
<p><strong>优化总结</strong></p>
<p>见图，😄</p>
<p><img src="https://i.loli.net/2021/05/06/9yxMB87tZuemvRq.png" alt="WX20210506-111104.png"></p>
<h3 id="监控机制？"><a href="#监控机制？" class="headerlink" title="监控机制？"></a>监控机制？</h3><p>瘦身完成之后，如何保证包大小不会再次迅速增大？就像减肥之后不会迅速反弹一样？就需要依赖适当的监控机制和合理的流程规范来控制。</p>
<p>监控机制保证实时发现问题，每次打包完成后，运行脚本比较包大小差异，如果有增大超过了设置的阈值，则邮件通知相关开发，开发关注排查是什么原因导致包大小变大；同时做好记录，每次打包的包大小变化及时注意记录，造成包大小变化的原因，落入文档。</p>
<p>流程规范是用于保证每个项目开发者知晓开发中注意什么，养成好的开发习惯，避免造成包大小的突然变大。</p>
<ul>
<li>引入新的三方库时，要考虑是否已有同类型的库，是否可以自己实现，是否会造成体积增大。尽量避免Objective-C和Swift混编，优先引用相同语言类型的库</li>
<li>新增的图片资源，关注大小，考虑是否能用Iconfont，是否能代码实现，注意放入项目的位置，如果体积太大，压缩后使用</li>
<li>废弃模块不要保留，及时清理</li>
<li>及时关注包大小变化，对于包大小变化的原因及结果整理落入文档，反馈总结</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>截止目前为止，笔者总体项目优化结果如下：</p>
<table>
<thead>
<tr>
<th align="center">优化内容</th>
<th align="center">ipa大小</th>
</tr>
</thead>
<tbody><tr>
<td align="center">原始</td>
<td align="center">22.9M</td>
</tr>
<tr>
<td align="center"><font color='Gold'>Xcode编译优化-Pod优化后</font></td>
<td align="center">21M</td>
</tr>
<tr>
<td align="center"><font color='Gold'>Xcode编译优化-Asset Catalog Compiler编译设置优化后</font></td>
<td align="center">20.7M</td>
</tr>
<tr>
<td align="center">Xcode编译优化-其它</td>
<td align="center">13.2M</td>
</tr>
<tr>
<td align="center">资源优化</td>
<td align="center">10.3M</td>
</tr>
</tbody></table>
<p>达到了预期瘦身的效果，虽然还有更进一步优化的空间，比如把项目中唯一引用的Swift的第三方库改为OC的，从而可以去除混编，能大幅缩减项目大小，但是由于需要改动业务代码，笔者暂时搁置了。</p>
<p>总的来说，笔者在业务代码没有改动的情况下，经过Xcode编译优化和资源文件压缩，把包大小从22.9M压缩到了10.3M，就结果来说是超出了预期。</p>
<p>但是作为优化包大小的实践来说还有待未完待续的地方，就是最后一步的代码优化，笔者打算单独抽一篇文章，来补充一下，使用代码优化的流程逻辑。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.zybuluo.com/qidiandasheng/note/1662385">包体积大小：瘦身</a></li>
<li><a target="_blank" rel="noopener" href="https://zhoujinying.github.io/2019/09/05/iOS%E5%8C%85%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96/">iOS包体积优化</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ByteDanceTech/article/details/112504772">抖音品质建设 - iOS 安装包大小优化实践篇</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cocoachina.com/articles/859032">干货！京东商城iOS App瘦身实践</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2c914530b54b">iOS 优化IPA包体积（今日头条）</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904169938092045#heading-15">深入探索 iOS 包体积优化</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247484366&idx=1&sn=5a2d0e981c733e9eaec274b835600e67&chksm=e9d0c82cdea7413ada372bb936541c2a49de664b38daa6137c179ab6177231fa8b00ddf9acbc&scene=21#wechat_redirect">干货|今日头条iOS端安装包大小优化—思路与实践</a></li>
<li><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/iowjwhbirqeobzf5m2o8">今日头条 iOS 安装包大小优化—— 新阶段、新实践</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a49d59b01669?utm_campaign=maleskine&utm_content=note&utm_medium=reader_share&utm_source=qzone">iOS 优化ipa包，减小安装包大小</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=207986417&idx=1&sn=77ea7d8e4f8ab7b59111e78c86ccfe66&3rd=MzA3MDU4NTYzMw==&scene=6#rd">iOS微信安装包瘦身</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://morganwang.cn">今是昨非</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://morganwang.cn/2021/05/27/iOS%20%E5%8C%85%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96/">http://morganwang.cn/2021/05/27/iOS%20%E5%8C%85%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://morganwang.cn" target="_blank">今是昨非的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%8A%80%E6%9C%AF/">技术</a><a class="post-meta__tags" href="/tags/iOS/">iOS</a></div><div class="post-share"><div class="social-share" data-image="/assets/img/avatar.jpeg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2021/06/07/CocoaPod%20%E7%A7%81%E6%9C%89%E5%BA%93Spec%E7%BC%96%E8%BE%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/" title="CocoaPod 私有库Spec依赖.a写法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">CocoaPod 私有库Spec依赖.a写法</div></div><div class="info-2"><div class="info-item-1">CocoaPod 私有库Spec编辑注意事项CocoaPod 私有库Spec依赖.a写法 PodSpec详细描述如下，    123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Pod::Spec.new do |s|  # 库名称  s.name             = &#x27;AudioRecorder&#x27;    # 库的版本  s.version          = &#x27;0.1.0&#x27;    # 库摘要  s.summary          = &#x27;AudioRecorder提供iOS录音和录音播放功能&#x27;  # 库描述  s.description      = &lt;&lt;-DESC						AudioRecorder提供iOS录音和录音播放功能                       DESC  # 远程...</div></div></div></a><a class="pagination-related" href="/2021/05/14/iOS%20%E5%B7%A5%E4%BD%9C%E6%97%A5%E2%80%94%E2%80%94%E8%BF%87%E6%BB%A4%E6%B3%95%E5%AE%9A%E8%8A%82%E5%81%87%E6%97%A5%E6%97%A5%E5%8E%86%E6%8F%90%E9%86%92%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="iOS 工作日——过滤法定节假日日历提醒的实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">iOS 工作日——过滤法定节假日日历提醒的实现</div></div><div class="info-2"><div class="info-item-1">iOS 工作日——过滤法定节假日日历提醒的实现背景笔者五一之前补班的时候，闹钟没响，早上差点迟到了。笔者闹钟设置的是周一到周五，iPhone没有法定节假日的设置，也没有补休的设置。。。。笔者就想要解决这个痛点，梦想着，要是做出来了，发布到商店，从此走上人生巅峰，赢取白。。。。   YY过后，回过头来，接着调研，法定节假日闹钟的实现，笔者查找了很多资料，发现不用做梦了。首先iOS程序添加闹钟到时钟APP是不允许的。。。其次，iOS也没有法定节假日的判断。。。。所以不用YY了。但是笔者还真找到了iOS自定义闹钟 —— 中国法定节假日(升级版）这个，通过快捷指令自定义闹钟，可以实现过滤法定节假日。原理是：设置闹钟，然后通过快捷指令的自动执行，每天在闹钟时间前，通过订阅的别人维护的日历或者自己本地维护日历，判断当天是否是节假日，然后决定当天的闹钟是否打开、关闭。笔者不得不赞一个，真的优秀。 虽然笔者的发财梦夭折了。。。但笔者想到了另一个，虽然iOS程序不能直接添加闹钟，但是iOS程序可以直接添加日历提醒啊，比如预约直播或者预约抢购的，其实都是添加事件到日历中，然后在指定的时间，弹出来日历...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/07/31/iOS%E9%9D%A2%E8%AF%95%E9%A2%98/" title="Swift 面试题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-31</div><div class="info-item-2">Swift 面试题</div></div><div class="info-2"><div class="info-item-1">背景被问到的面试题，这里记录一下。   问题Swift 中 Struct 和 Class 的区别Swift 中 为什么 String、Array、Dictionary 用 Struct 实现Swift 中写时复制的原理Swift 中变量作用域有哪些，区别是什么Swift中 Protocol 如何声明可空MVP 的优点是什么RxSwift 中冷信号和热信号的区别RxSwift 中 CombineLatest、zip、merge的区别Git 中 rebase和 merge 的区别，rebased的 commitID 会改变吗SwiftUI 中 View 传值方式有哪些什么情况下触发 layoutSubviews 答案Swift 中 Struct 和 Class 的区别Struct是值类型，Class 是引用类型；Struct和 Class 都可以有属性和方法，但是 let 修饰的 Struct 不能更改，Class 修饰的可以更改；Struct方法中修改属性需要在方法前添加 mutating 关键字。Struct和 Class 都可以实现协议。Struct不能被继承，Class 可以...</div></div></div></a><a class="pagination-related" href="/2021/08/04/iOS%E8%99%9A%E6%8B%9F%E4%BD%8D%E7%BD%AE%E8%B0%83%E7%A0%94%E4%B8%8E%E9%A2%84%E9%98%B2/" title="iOS 虚拟定位原理与预防"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-04</div><div class="info-item-2">iOS 虚拟定位原理与预防</div></div><div class="info-2"><div class="info-item-1">iOS 虚拟定位原理与预防背景说到虚拟定位，常有印象都是安卓上的分身软件甚至系统自带的位置穿越（笔者曾经使用过ZUK Z2系统自带的位置穿越），会认为iOS上虚拟定位比较困难。笔者没调研之前也是这么认为，之前已知的虚拟定位是使用Xcode添加GPX文件，编辑经纬度，从而实现虚拟定位。但是这种操作也只有熟悉iOS开发的人才能操作，而且需要mac电脑，故而笔者印象中也是iOS上虚拟定位比较困难。   然而经过调研之后，笔者发现，iOS的虚拟定位没有那么困难，甚至相比于安卓更简单。下面就来介绍一下iOS中几种虚拟定位的方法。 虚拟定位的几种办法及原理笔者调研后，发现iOS上面虚拟定位大致可有4中情况：  使用Xcode通过GPX文件虚拟定位 使用爱思助手中的虚拟定位功能直接虚拟定位 通过外接设备，比如蓝牙和手机连接，发送虚拟定位数据来虚拟定位 越狱设备中通过hook定位方法，来虚拟定位  下面就来一个个分析实践： 使用Xcode通过GPX文件虚拟定位使用Xcode通过GPX文件虚拟定位，iOS开发一般比较熟悉，操作步骤是： 新创建一个iOS项目，然后添加文件，选择创建GPX文件  编辑...</div></div></div></a><a class="pagination-related" href="/2021/12/27/iOS%20SDK%20%E4%B8%8D%E6%94%AF%E6%8C%81%E6%A8%A1%E6%8B%9F%E5%99%A8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/" title="iOS SDK 不支持模拟器解决办法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-27</div><div class="info-item-2">iOS SDK 不支持模拟器解决办法</div></div><div class="info-2"><div class="info-item-1">背景iOS 第三方 SDK 不支持模拟器，报错提示: building for ios simulator, but the linked framework ‘’xxx(比如: IDLFaceSDK.framework)” was built for ios 解决办法.。   解决办法首先，在Target -&gt; BuildSettings -&gt; Excluded Source FileNames -&gt; Debug 中添加一行，注意，key选择 Any iOS Simulator SDK，value 中添加报错中提示的 SDK的目录，示例如下：  然后，在项目中，引用对应 SDK 头文件，以及使用 SDK 方法的地方添加如下代码判断 1234567891011121314#if !(TARGET_IPHONE_SIMULATOR)#import &lt;xxx/xxx.h&gt;#endif#if !(TARGET_IPHONE_SIMULATOR)[xxx share].yyy = xxx;#endif </div></div></div></a><a class="pagination-related" href="/2024/11/19/%E5%9B%BD%E8%A1%8CXcode%20%E4%BD%BF%E7%94%A8%20AI/" title="国行Mac 开启 Xcode inteligence 提示"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-19</div><div class="info-item-2">国行Mac 开启 Xcode inteligence 提示</div></div><div class="info-2"><div class="info-item-1">背景电脑国行 Mac M1，内存 16G，版本 Sequoia 15.1，Xcode 16.1，在Xcode 设置中，Text Editing 下，Editing Tab下，能看到有个设置Predictive code completion，但是默认是关闭的， 国行的提示不支持，这里说的是怎么开启这个，亲测开启成功。   最终效果如下：    步骤参考XcodeLLMEligible，我用的是不 disable sip 的方式。 首先，在终端中，输入下面命令： 12345678# Override XcodeLLM onlycurl -L https://raw.githubusercontent.com/Kyle-Ye/XcodeLLMEligible/release/0.2/scripts/override.sh | bash -s -- install override xcodellm# Override Apple Intelligence onlycurl -L https://raw.githubusercontent.com/Kyle-Ye/XcodeLLMEli...</div></div></div></a><a class="pagination-related" href="/2021/07/29/iOS%20RC4%E5%8A%A0%E5%AF%86/" title="iOS RC4加密"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-29</div><div class="info-item-2">iOS RC4加密</div></div><div class="info-2"><div class="info-item-1">iOS RC4加密iOS RC4加密的实现，要注意加密后生成字符串的步骤，有些要求是base64加密后输出，有些要求是字节数组转16进制字符串输出，所以要特别注意。   代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125// rc4加密- (NSString *)rc4Encode:(NSString *)aInput key:(NSString *)aKey &#123;    NSMutableArray *iS = [[NSMutableArray alloc] initWithCapa...</div></div></div></a><a class="pagination-related" href="/2023/02/22/CABasicAnimation%E8%BF%9B%E5%85%A5%E4%BA%8C%E7%BA%A7%E7%95%8C%E9%9D%A2%E5%86%8D%E5%9B%9E%E6%9D%A5%E4%B8%8D%E7%94%9F%E6%95%88/" title="CABasicAnimation进入二级界面再回来不生效"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-22</div><div class="info-item-2">CABasicAnimation进入二级界面再回来不生效</div></div><div class="info-2"><div class="info-item-1">背景发现之前同事写的某个界面有个动效, 起初进入的时候是生效的, 进入二级界面再返回动效就没了, 动画用的是CABasicAnimation, 添加在 layer 上面.    解决看代码没有问题, 毕竟第一次就生效了, 以为是在页面消失时做了什么操作, 查了之后发现, 页面消失时并没有操作. 再回过来看代码, 代码动画部分是在didMoveToWindow中实现的, 大致如下: didMoveToWindow方法在页面消失和出现的时候都会调用, 难道是添加多次导致不生效了, 改成只添加一次之后发现效果一样, 进入二级页面再返回就不生效了. 1234567891011override func didMoveToWindow() &#123;     layer.addSublayer(gradientLayer)     let basicAnim = CABasicAnimation(keyPath: &quot;animateLocation&quot;)     basicAnim.fromValue = [xxx]     basicAnim.toValue = [xx...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/assets/img/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">今是昨非</div><div class="author-info-description">技术分享、生活感悟</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">188</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/mokong"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/mokong" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://x.com/morgan2015_wang" target="_blank" title="Twitter"><i class="fab fa-X"></i></a><a class="social-icon" href="mailto:mokong.2015.1992@email.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#iOS-%E5%8C%85%E5%A4%A7%E5%B0%8F%E5%88%86%E6%9E%90%E4%BC%98%E5%8C%96"><span class="toc-number">1.</span> <span class="toc-text">iOS 包大小分析优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">1.1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">1.2.</span> <span class="toc-text">分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E5%8C%85%E7%9A%84%E6%9E%84%E6%88%90"><span class="toc-number">1.2.1.</span> <span class="toc-text">安装包的构成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Xcode%E7%BC%96%E8%AF%91%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.2.2.</span> <span class="toc-text">Xcode编译设置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Xcode%E7%BC%96%E8%AF%91%E8%AE%BE%E7%BD%AE%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">Xcode编译设置优化总结如下：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E4%BC%98%E5%8C%96"><span class="toc-number">1.2.3.</span> <span class="toc-text">资源文件优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%94%A8%E8%B5%84%E6%BA%90%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">无用资源的删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%B2%E7%94%A8%E8%B5%84%E6%BA%90%E7%9A%84%E5%8E%8B%E7%BC%A9"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">已用资源的压缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">资源文件优化总结如下：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">1.2.4.</span> <span class="toc-text">监控机制？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">1.4.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/22/Google%20Antigravity%20%E7%99%BB%E5%BD%95%E4%B8%8D%E4%BA%86%E8%A7%A3%E5%86%B3/" title="Google 的 Antigravity登录不了解决">Google 的 Antigravity登录不了解决</a><time datetime="2026-01-22T02:48:00.000Z" title="发表于 2026-01-22 10:48:00">2026-01-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/22/%E5%85%B3%E4%BA%8E%20AI%20%E4%B8%8E%E5%BC%80%E5%8F%91/" title="关于 AI 与开发">关于 AI 与开发</a><time datetime="2026-01-22T02:48:00.000Z" title="发表于 2026-01-22 10:48:00">2026-01-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/21/%E8%BF%9E%E5%A4%9C%E5%BC%80%E5%8F%91%E4%BA%86%E4%B8%80%E4%B8%AA%20Mac%20%E4%B8%8A%E4%B9%85%E5%9D%90%E6%8F%90%E9%86%92%E5%B7%A5%E5%85%B7/" title="连夜开发了一个 Mac 上久坐提醒工具">连夜开发了一个 Mac 上久坐提醒工具</a><time datetime="2026-01-21T09:22:00.000Z" title="发表于 2026-01-21 17:22:00">2026-01-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/13/%E9%B8%BF%E8%92%99%E6%88%AA%E5%9B%BE%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7/" title="无标题">无标题</a><time datetime="2025-10-13T07:24:22.000Z" title="发表于 2025-10-13 15:24:22">2025-10-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/28/%E4%BD%BF%E7%94%A8%E4%B8%80%E8%A1%8C%E5%91%BD%E4%BB%A4%E5%AE%9E%E7%8E%B0OpenConnect%E8%BF%9E%E6%8E%A5%E5%86%85%E7%BD%91/" title="无标题">无标题</a><time datetime="2025-09-28T07:28:52.000Z" title="发表于 2025-09-28 15:28:52">2025-09-28</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2026 By 今是昨非</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 5.4.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div><div class="footer_custom_text"><span>日出江花红胜火，春来江水绿如蓝，能不忆江南</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      false
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>